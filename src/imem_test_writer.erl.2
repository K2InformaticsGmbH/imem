-module(imem_test_writer).

-include("imem.hrl").        % import logging macros
-include("imem_meta.hrl").   % import exceptions and data types

-behavior(gen_server).       % implicitly defines the required callbacks

-record(ddTest,   % test table record definition with erlang types
                  { time    :: ddTimestamp() % {Megas,Secs,Micros}
                  , x       :: integer()        
                  , y       :: integer()
                  , z       :: float()
                  , label   :: list()
                  }
       ).
-define(ddTest, [timestamp,integer,integer,float,string]).  % test table DDerl types
-define(ddTestName,ddTest@).  %% node sharded test table (local content per node) 

-record(state0, % process state (stateless apart from delay)
                { wait      :: integer()}   % event delay
       ).
-record(state1, % extended process state with coordinates and label
                { wait      :: integer()    % event delay
                , x         :: integer()    % current x pos
                , y         :: integer()    % current y pos
                , z         :: float()      % generation 0..3
                , label     :: list()       % object name
                }
       ).

% gen_server API call exports

-export([ start/1
        , stop/0
        , wait/1
        , write_test_record/4
        ]).

% sample usage for demo:
% imem_test_writer:start(1000). % 1 second event loop
% imem_test_writer:stop().
% imem_test_writer:wait(100).
% l(imem_test_writer).          % module load -> apply the patch

% gen_server behavior callback exports

-export([ start_link/1
        , init/1
        , handle_call/3
        , handle_cast/2
        , handle_info/2
        , terminate/2
        , code_change/3
        ]).

start(Wait) ->
    ChildSpec = { imem_test_writer                      % ChildId
                , {imem_test_writer,start_link,[Wait]}  % {M,F,A}
                , permanent                             % Restart strategy
                , 1000                                  % Shutdown timeout
                , worker                                % Type
                , [imem_test_writer]                    % Modules
                },
    supervisor:start_child(imem_sup, ChildSpec).

stop() ->
    supervisor:terminate_child(imem_sup, imem_test_writer),
    supervisor:delete_child(imem_sup, imem_test_writer).

wait(Wait) when is_integer(Wait) ->
    gen_server:call(?MODULE, {wait, Wait}). 

start_link(Wait) when is_integer(Wait) ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, Wait, []).

timestamp() -> erlang:now().

write_test_record(X,Y,Z,Label) ->
    Record = #ddTest{ time=timestamp()
                    , x=X
                    , y=Y
                    , z=Z
                    , label=Label
                    },
    imem_meta:dirty_write(?ddTestName, Record).

lead({Mega,Secs,_}) ->
    Phase = 0.051*math:pi()*(Mega*1000000 + Secs), 
    {round(1000*math:cos(Phase)), round(500*math:sin(Phase))}.

% gen_server behavior callback implementation

init(Wait) when is_integer(Wait) ->
    random:seed(timestamp()),
    imem_meta:create_check_table(?ddTestName, {record_info(fields, ddTest),?ddTest, #ddTest{}}, [{type,ordered_set},{record_name,ddTest}], system),
    imem_meta:truncate_table(?ddTestName),
    imem_test_writer:write_test_record(0,0,0.0,"starting--------------"),
    erlang:send_after(Wait, self(), next_event),    
    {ok,#state0{wait=Wait}}.

terminate(_Reason, _State) -> ok.
code_change(_OldVsn, State, _Extra) -> {ok, State}.
handle_cast(_Request, State) -> {noreply, State}.

handle_call({wait, Wait}, _From, #state1{}=State) ->
    {reply, ok, State#state1{wait=Wait}};
handle_call({wait, Wait}, _From, #state0{}=State) ->
    {reply, ok, State#state0{wait=Wait}};
handle_call(stop, _From, State) ->
    {stop, normal, ok, State}.

handle_info(next_event, #state1{wait=Wait,z=Z,label=N}=State) ->
    {X,Y} = lead(timestamp()),
    imem_test_writer:write_test_record(X,Y,Z,N),
    erlang:send_after(Wait, self(), next_event),
    {noreply, State#state1{x=X,y=Y}};
handle_info(next_event, #state0{wait=Wait}) ->
    N = "Node",
    Z = 0.0,
    {X,Y} = lead(timestamp()),
    imem_meta:truncate_table(?ddTestName),
    imem_test_writer:write_test_record(X,Y,Z,N),
    erlang:send_after(Wait, self(), next_event),
    {noreply, #state1{x=X,y=Y,z=Z,wait=Wait,label=N}}.
